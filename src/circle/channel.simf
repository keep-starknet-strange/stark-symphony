// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

//! A non-interactive channel for communication between the prover and the verifier.
//! The channel is based on the SHA-256 hash function.

#ifndef CIRCLE_CHANNEL_SIMF
#define CIRCLE_CHANNEL_SIMF

#include "utils/sha256.simf"
#include "circle/fields/m31.simf"
#include "circle/fields/qm31.simf"
#include "circle/groups/qm31_point.simf"

/// The channel state is a 256-bit value, initialized to 0.
type ChannelState = u256;

/// Get a 256-bit value from the channel state by hashing it + zero byte.
fn channel_get_u256(state: ChannelState) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, state);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_1(ctx, 0);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// Mix a u256 value into the channel state.
///
/// # Arguments
///
/// * `state` - The current channel state.
/// * `input` - The value to mix into the channel state.
fn channel_mix_256(state: ChannelState, input: u256) -> ChannelState {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, state);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, input);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// Update the channel state by hashing the current state.
fn channel_mix(state: ChannelState) -> ChannelState {
    sha256(state)
}

/// Draw a QM31 value from the channel state.
fn channel_draw_qm31(state: ChannelState) -> (ChannelState, QM31) {
    let value: u256 = channel_get_u256(state);
    let (abcd, _): (u128, u128) = <u256>::into(value);
    let (ab, cd): (u64, u64) = <u128>::into(abcd);
    let (a, b): (u32, u32) = <u64>::into(ab);
    let (c, d): (u32, u32) = <u64>::into(cd);
    let value: QM31 = qm31(m31(a), m31(b), m31(c), m31(d));
    (channel_mix(state), value)
}

/// Draw a QM31 point from the channel state.
fn channel_draw_qm31_point(state: ChannelState) -> (ChannelState, QM31Point) {
    let (state, t): (ChannelState, QM31) = channel_draw_qm31(state);
    let t_sq: QM31 = qm31_pow2(t);
    let t_sq_plus_1_inv: QM31 = qm31_inv(qm31_add(qm31_one(), t_sq));
    let x: QM31 = qm31_mul(qm31_sub(qm31_one(), t_sq), t_sq_plus_1_inv);
    let y: QM31 = qm31_mul(qm31_add(t, t), t_sq_plus_1_inv);
    (state, (x, y))
}

fn test_channel_draw_qm31() {
    let state: ChannelState = 0;
    let (state, value): (ChannelState, QM31) = channel_draw_qm31(state);
    assert!(qm31_eq(value, qm31(2140970545, 746739403, 790988163, 1596337597)));
}

fn test_channel_draw_qm31_point() {
    let state: ChannelState = 0;
    let (state, value): (ChannelState, QM31Point) = channel_draw_qm31_point(state);
    let x: QM31 = qm31(1116780557, 2044256354, 1723700012, 1755363094);
    let y: QM31 = qm31(2138743810, 1953780644, 577089820, 497750207);
    assert!(qm31_point_eq(value, (x, y)));
}

#endif
